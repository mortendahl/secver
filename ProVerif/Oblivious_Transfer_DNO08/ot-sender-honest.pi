(****************************************
*  Oblivious Transfer protocol [DNO08] 
*   - when only sender is honest
*****************************************)

set attacker = active.
set movenew = true.
set selFun = NounifsetMaxsize.

(***** Preamble *****)

type rand.	(* randomness *)
type ekey.	(* encryption key *)
type dkey.	(* decryption key *)
type ckey.	(* commitment key *)
type crstring.	(* common reference string *)
type extrdoor.	(* proof extraction trapdoor *)
type ciphertext.
type commitment.
type zkproof.

fun crsfor(extrdoor) : crstring.
fun ekfor(dkey) : ekey.

(** Tags for termination **)
type tag.
const tagzero:tag.
const tagone:tag.

(** Domain **)
type value.	
const zero:value.
const one:value.
const two:value.

(** Channels **)
free inS : channel.
free inR : channel.
free outS : channel.
free outR : channel.
free leakRS : channel.
free inflRS : channel.
free leakSR : channel.
free inflSR : channel.
free leaksetup : channel.
free advcommituin : channel.
free advcommituout : channel.
free advencrypttin : channel.
free advencrypttout : channel.
free advevalein : channel.
free advevaleout : channel.

(** Types **)
(* U = Dom = { 0, 1, 2 } *)
reduc inU( zero ) = true; inU( one ) = true; inU( two ) = true.
(* T = Bit = { 0, 1 } *)
reduc inT( zero ) = true; inT( one ) = true; inT( two ) = false.

(** Commitment **)
fun com(value, rand, ckey) : commitment.
fun uproof(commitment, ckey, crstring) : zkproof [private].
reduc (* verComPack *)
  forall d:commitment, ck:ckey, crs:crstring; 
  verComPack( d, ck, uproof(d,ck,crs), crs ) = true.
reduc (* extractCom *)
  forall v:value, r:rand, ck:ckey, extd:extrdoor; 
  extractCom( uproof(com(v,r,ck),ck,crsfor(extd)), extd ) = v.

(** Encryption **)
fun enc(tag, value, rand, ekey) : ciphertext.
fun tproof(ciphertext, ekey, crstring) : zkproof [private].
reduc (* dec *)
  forall t:tag, v:value, r:rand, dk:dkey; 
   dec( enc(t,v,r,ekfor(dk)), dk ) = v.
reduc (* verEndPack *)
  forall c:ciphertext, ek:ekey, crs:crstring;
   verEncPack( c, ek, tproof(c,ek,crs), crs ) = true.
reduc (* extractEnc *)
  forall t:tag, v:value, r:rand, ek:ekey, extd:extrdoor;
   extractEnc( tproof(enc(t,v,r,ek),ek,crsfor(extd)), extd ) = v.

(** Evaluation **)
fun eproof(ciphertext,ciphertext,ekey,commitment,commitment,ckey,crstring) : zkproof [private].
reduc (* evale for sel = x0*(1-b) + x1*b *)
  forall v:value, r:rand, ek:ekey, x0:value, x1:value, newr:rand;
   evale( enc(tagone,zero,r,ek), x0, x1, newr ) = enc(tagzero,x0,newr,ek);	
  forall v:value, r:rand, ek:ekey, x0:value, x1:value, newr:rand;
   evale( enc(tagone,one,r,ek), x0, x1, newr ) = enc(tagzero,x1,newr,ek);
  forall v:value, r:rand, ek:ekey, x0:value, x1:value, newr:rand;
   evale( enc(tagone,two,r,ek), zero, zero, newr ) = enc(tagzero,zero,newr,ek);
  forall v:value, r:rand, ek:ekey, x0:value, x1:value, newr:rand;
   evale( enc(tagone,two,r,ek), zero, one, newr ) = enc(tagzero,two,newr,ek);
  forall v:value, r:rand, ek:ekey, x0:value, x1:value, newr:rand;
   evale( enc(tagone,two,r,ek), zero, two, newr ) = enc(tagzero,one,newr,ek);
  forall v:value, r:rand, ek:ekey, x0:value, x1:value, newr:rand;
   evale( enc(tagone,two,r,ek), one, zero, newr ) = enc(tagzero,two,newr,ek);
  forall v:value, r:rand, ek:ekey, x0:value, x1:value, newr:rand;
   evale( enc(tagone,two,r,ek), one, one, newr ) = enc(tagzero,one,newr,ek);
  forall v:value, r:rand, ek:ekey, x0:value, x1:value, newr:rand;
   evale( enc(tagone,two,r,ek), one, two, newr ) = enc(tagzero,zero,newr,ek);
  forall v:value, r:rand, ek:ekey, x0:value, x1:value, newr:rand;
   evale( enc(tagone,two,r,ek), two, zero, newr ) = enc(tagzero,two,newr,ek);
  forall v:value, r:rand, ek:ekey, x0:value, x1:value, newr:rand;
   evale( enc(tagone,two,r,ek), two, one, newr ) = enc(tagzero,one,newr,ek);
  forall v:value, r:rand, ek:ekey, x0:value, x1:value, newr:rand;
   evale( enc(tagone,two,r,ek), two, two, newr ) = enc(tagzero,zero,newr,ek) [private].
reduc (* verEvalPack *)
  forall c:ciphertext,c1:ciphertext,ek:ekey,d1:commitment,d2:commitment,ck:ckey,crs:crstring;
   verEvalPack( c, c1, ek, d1, d2, ck, eproof(c, c1, ek, d1, d2, ck, crs), crs ) = true.
reduc (* extractEval1 *)
  forall c:ciphertext,c1:ciphertext,ek:ekey,v1:value,r1:rand,d2:commitment,ck:ckey,extd:extrdoor;
   extractEval1( eproof(c, c1, ek, com(v1, r1, ck), d2, ck, crsfor(extd)), extd ) = v1.
reduc (* extractEval2 *)
  forall c:ciphertext,c1:ciphertext,ek:ekey,d1:commitment,v2:value,r2:rand,ck:ckey,extd:extrdoor;
   extractEval2( eproof(c, c1, ek, d1, com(v2, r2, ck), ck, crsfor(extd)), extd ) = v2.

(***** Adversary Oracles *****)

let advcommitu(ck:ckey, crs:crstring) =
  in(advcommituin, (v:value, r:rand));
  if inU(v) then (
    let d = com(v, r, ck) in
    let p = uproof(d, ck, crs) in
    let pack = (d, ck, p, crs) in
    out(advcommituout, pack)
  ).

let advencryptt(ek:ekey, crs:crstring) =
  in(advencrypttin, (v:value, r:rand));
  if inT(v) then (
    let c = enc(tagone, v, r, ek) in
    let p = tproof(c, ek, crs) in
    let pack = (c, ek, p, crs) in
    out(advencrypttout, pack)
  ).

let advevale(ek:ekey, ck:ckey, crs:crstring) =
  in(advevalein, (cb:ciphertext, x0:value, r0:rand, x1:value, r1:rand));
  new newr:rand;
  let cx = evale(cb, x0, x1, newr) in
  let d0 = com(x0, r0, ck) in
  let d1 = com(x1, r1, ck) in
  let p = eproof(cx, cb, ek, d0, d1, ck, crs) in
  let pack = (cx, cb, ek, d0, d1, ck, p, crs) in
  out(advevaleout, pack).

(***** Merged Real+Ideal Protocol *****)

let mergedProtocol(ckS:ckey, ekR:ekey, crsS:crstring, crsR:crstring, extdR:extrdoor) =

  (* Step 1 *)
  in(inflRS, (cb:ciphertext, ek:ekey, pb:zkproof, crs:crstring));
  if verEncPack(cb, ekR, pb, crsR) then (
    let b = extractEnc(pb, extdR) in

    (* Step 2 *)
    in(inS, (v0:value, v1:value));
    if inU(v0) && inU(v1) then (
      if b = zero then (
        new r:rand;
        new r0:rand;
        new r1:rand;
        let cv = choice[evale(cb, v0, v1, r), enc(tagzero, v0, r, ekR)] in
        let d0 = com(choice[v0,zero], r0, ckS) in
        let d1 = com(choice[v1,zero], r1, ckS) in
        let pv = eproof(cv, cb, ekR, d0, d1, ckS, crsS) in
        let cvpack = (cv, cb, ekR, d0, d1, ckS, pv, crsS) in
        out(leakSR, cvpack)
      ) else (
        new r:rand;
        new r0:rand;
        new r1:rand;
        let cv = choice[evale(cb, v0, v1, r), enc(tagzero, v1, r, ekR)] in
        let d0 = com(choice[v0,zero], r0, ckS) in
        let d1 = com(choice[v1,zero], r1, ckS) in
        let pv = eproof(cv, cb, ekR, d0, d1, ckS, crsS) in
        let cvpack = (cv, cb, ekR, d0, d1, ckS, pv, crsS) in
        out(leakSR, cvpack)
      )
    )
  ).


process 
(
  new ckS:ckey;
  new ckR:ckey;
  new dkS:dkey;
  new dkR:dkey;
  let ekS = ekfor(dkS) in
  let ekR = ekfor(dkR) in
  new extdS:extrdoor;
  new extdR:extrdoor;
  let crsS = crsfor(extdS) in
  let crsR = crsfor(extdR) in
  out(leaksetup, (ckS, ckR, ekS, ekR, crsS, crsR, dkR));
  (
    ( ! advcommitu(ckS, crsS) ) |
    ( ! advencryptt(ekR, crsR) ) |
    ( ! advevale(ekR, ckS, crsS) ) |
    mergedProtocol(ckS, ekR, crsS, crsR, extdR)
  )
)